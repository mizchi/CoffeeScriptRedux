// Generated by TypedCoffeeScript 0.8.3
var ArrayType, checkAcceptableObject, ClassScope, clone, console, FunctionScope, initializeGlobalTypes, ObjectType, pj, Possibilites, render, reporter, rewrite, Scope, Type, TypeSymbol, VarSymbol;
console = {
  log: function () {
  }
};
pj = function () {
  try {
    return require('prettyjson');
  } catch (e$) {
    return;
  }
}.call(this);
render = function (obj) {
  if (null != pj)
    return pj.render(obj);
};
cache$ = require('./type-helpers');
clone = cache$.clone;
rewrite = cache$.rewrite;
reporter = require('./reporter');
Type = function () {
  function Type() {
  }
  return Type;
}();
ObjectType = function (super$) {
  extends$(ObjectType, super$);
  function ObjectType(param$) {
    this.type = param$;
  }
  return ObjectType;
}(Type);
ArrayType = function (super$) {
  extends$(ArrayType, super$);
  function ArrayType(type) {
    this.array = type;
  }
  return ArrayType;
}(Type);
Possibilites = function (super$) {
  extends$(Possibilites, super$);
  function Possibilites(arr) {
    var i;
    if (null == arr)
      arr = [];
    for (var i$ = 0, length$ = arr.length; i$ < length$; ++i$) {
      i = arr[i$];
      this.push(i);
    }
  }
  return Possibilites;
}(Array);
checkAcceptableObject = function (this$) {
  return function (left, right, scope) {
    var cur, extended_list, results;
    if (null != (null != left ? left._base_ : void 0) && null != left._templates_)
      left = left._base_;
    console.log('checkAcceptableObject /', left, right);
    if (null != (null != right ? right.possibilities : void 0)) {
      results = function (accum$) {
        var r;
        for (var i$ = 0, length$ = right.possibilities.length; i$ < length$; ++i$) {
          r = right.possibilities[i$];
          accum$.push(checkAcceptableObject(left, r, scope));
        }
        return accum$;
      }.call(this$, []);
      return results.every(function (i) {
        return !i;
      }) ? false : results.filter(function (i) {
        return i;
      }).join('\n');
    }
    if (left === 'Any')
      return false;
    if (null != left ? left._args_ : void 0) {
      if (left === void 0 || left === 'Any')
        return;
      if (null != left._args_)
        left._args_;
      else
        left._args_ = [];
      results = function (accum$) {
        var i, l_arg;
        for (var i$ = 0, length$ = left._args_.length; i$ < length$; ++i$) {
          l_arg = left._args_[i$];
          i = i$;
          accum$.push(checkAcceptableObject(l_arg, right._args_[i], scope));
        }
        return accum$;
      }.call(this$, []);
      return results.every(function (i) {
        return !i;
      }) ? false : results.filter(function (i) {
        return i;
      }).join('\n');
      if (right._return_ !== 'Any')
        return checkAcceptableObject(left._return_, right._return_, scope);
      return false;
    }
    if (null != (null != left ? left.array : void 0)) {
      if (right.array instanceof Array) {
        results = function (accum$) {
          var r;
          for (var i$ = 0, length$ = right.array.length; i$ < length$; ++i$) {
            r = right.array[i$];
            accum$.push(checkAcceptableObject(left.array, r, scope));
          }
          return accum$;
        }.call(this$, []);
        return results.every(function (i) {
          return !i;
        }) ? false : results.filter(function (i) {
          return i;
        }).join('\n');
      } else {
        return checkAcceptableObject(left.array, right.array, scope);
      }
    } else if (null != (null != right ? right.array : void 0)) {
      if (left === 'Array' || left === 'Any' || left === void 0) {
        return false;
      } else {
        return 'object deep equal mismatch ' + JSON.stringify(left) + ', ' + JSON.stringify(right);
      }
    } else if (typeof left === 'string' && typeof right === 'string') {
      cur = scope.getTypeInScope(left);
      extended_list = [left];
      while (cur._extends_) {
        extended_list.push(cur._extends_);
        cur = scope.getTypeInScope(cur._extends_);
      }
      if (left === 'Any' || right === 'Any' || in$(right, extended_list)) {
        return false;
      } else {
        return 'object deep equal mismatch ' + JSON.stringify(left) + ', ' + JSON.stringify(right);
      }
    } else if (typeof left === 'object' && typeof right === 'object') {
      results = function (accum$) {
        var key, lval;
        for (key in left) {
          lval = left[key];
          accum$.push(right[key] === void 0 && ('undefined' !== typeof lval && null != lval) && !(key === '_return_' || key === 'type' || key === 'possibilities') ? "'" + key + "' is not defined on right" : checkAcceptableObject(lval, right[key], scope));
        }
        return accum$;
      }.call(this$, []);
      return results.every(function (i) {
        return !i;
      }) ? false : results.filter(function (i) {
        return i;
      }).join('\n');
    } else if (left === void 0 || right === void 0) {
      return false;
    } else {
      return 'object deep equal mismatch ' + JSON.stringify(left) + ', ' + JSON.stringify(right);
    }
  };
}(this);
initializeGlobalTypes = function (node) {
  node.addTypeObject('String', new TypeSymbol({ type: 'String' }));
  node.addTypeObject('Number', new TypeSymbol({
    type: 'Number',
    _extends_: 'Float'
  }));
  node.addTypeObject('Int', new TypeSymbol({ type: 'Int' }));
  node.addTypeObject('Float', new TypeSymbol({
    type: 'Float',
    _extends_: 'Int'
  }));
  node.addTypeObject('Boolean', new TypeSymbol({ type: 'Boolean' }));
  node.addTypeObject('Object', new TypeSymbol({ type: 'Object' }));
  node.addTypeObject('Array', new TypeSymbol({ type: 'Array' }));
  node.addTypeObject('Undefined', new TypeSymbol({ type: 'Undefined' }));
  return node.addTypeObject('Any', new TypeSymbol({ type: 'Any' }));
};
VarSymbol = function () {
  function VarSymbol(param$) {
    var cache$1;
    {
      cache$1 = param$;
      this.type = cache$1.type;
      this.implicit = cache$1.implicit;
    }
  }
  return VarSymbol;
}();
TypeSymbol = function () {
  function TypeSymbol(param$) {
    var cache$1;
    {
      cache$1 = param$;
      this.type = cache$1.type;
      this['instanceof'] = cache$1['instanceof'];
      this._templates_ = cache$1._templates_;
      this._extends_ = cache$1._extends_;
    }
  }
  return TypeSymbol;
}();
Scope = function () {
  function Scope(param$) {
    var instance$;
    instance$ = this;
    this.extendTypeLiteral = function (a) {
      return Scope.prototype.extendTypeLiteral.apply(instance$, arguments);
    };
    if (null == param$)
      param$ = null;
    this.parent = param$;
    if (null != this.parent)
      this.parent.nodes.push(this);
    this.name = '';
    this.nodes = [];
    this._vars = {};
    this._types = {};
    this._this = {};
    this._returnables = [];
  }
  Scope.prototype.addReturnable = function (symbol, type) {
    return this._returnables.push(type);
  };
  Scope.prototype.getReturnables = function () {
    return this._returnables;
  };
  Scope.prototype.addType = function (symbol, type, _templates_) {
    return this._types[symbol] = new TypeSymbol({
      type: type,
      _templates_: _templates_
    });
  };
  Scope.prototype.addTypeObject = function (symbol, type_object) {
    return this._types[symbol] = type_object;
  };
  Scope.prototype.getType = function (symbol) {
    return this._types[symbol];
  };
  Scope.prototype.getTypeInScope = function (symbol) {
    return this.getType(symbol) || (null != this.parent ? this.parent.getTypeInScope(symbol) : void 0) || void 0;
  };
  Scope.prototype.addThis = function (symbol, type, implicit) {
    var n, obj, replacer, rewrite_to, T, t;
    if (null == implicit)
      implicit = true;
    if (null != (null != type ? type._base_ : void 0)) {
      T = this.getType(type._base_);
      if (!T)
        return;
      obj = clone(T.type);
      if (T._templates_) {
        rewrite_to = type._templates_;
        replacer = {};
        for (var i$ = 0, length$ = T._templates_.length; i$ < length$; ++i$) {
          t = T._templates_[i$];
          n = i$;
          replacer[t] = rewrite_to[n];
        }
        rewrite(obj, replacer);
      }
      return this._this[symbol] = new VarSymbol({
        type: obj,
        implicit: implicit
      });
    } else {
      return this._this[symbol] = new VarSymbol({
        type: type,
        implicit: implicit
      });
    }
  };
  Scope.prototype.getThis = function (symbol) {
    return this._this[symbol];
  };
  Scope.prototype.addVar = function (symbol, type, implicit) {
    var n, obj, replacer, rewrite_to, T, t;
    if (null == implicit)
      implicit = true;
    if (null != (null != type ? type._base_ : void 0)) {
      T = this.getType(type._base_);
      if (!T)
        return;
      obj = clone(T.type);
      if (T._templates_) {
        rewrite_to = type._templates_;
        replacer = {};
        for (var i$ = 0, length$ = T._templates_.length; i$ < length$; ++i$) {
          t = T._templates_[i$];
          n = i$;
          replacer[t] = rewrite_to[n];
        }
        rewrite(obj, replacer);
      }
      return this._vars[symbol] = new VarSymbol({
        type: obj,
        implicit: implicit
      });
    } else {
      return this._vars[symbol] = new VarSymbol({
        type: type,
        implicit: implicit
      });
    }
  };
  Scope.prototype.getVar = function (symbol) {
    return this._vars[symbol];
  };
  Scope.prototype.getVarInScope = function (symbol) {
    return this.getVar(symbol) || (null != this.parent ? this.parent.getVarInScope(symbol) : void 0) || void 0;
  };
  Scope.prototype.isImplicitVar = function (symbol) {
    return !!(null != this._vars[symbol] ? this._vars[symbol].implicit : void 0);
  };
  Scope.prototype.isImplicitVarInScope = function (symbol) {
    return this.isImplicitVar(symbol) || (null != this.parent ? this.parent.isImplicitVarInScope(symbol) : void 0) || void 0;
  };
  Scope.prototype.extendTypeLiteral = function (node) {
    var key, ret, type, val;
    switch (typeof node) {
    case 'object':
      if (node instanceof Array) {
        return function (accum$) {
          var i;
          for (var i$ = 0, length$ = node.length; i$ < length$; ++i$) {
            i = node[i$];
            accum$.push(this.extendTypeLiteral(i));
          }
          return accum$;
        }.call(this, []);
      } else {
        ret = {};
        for (key in node) {
          val = node[key];
          ret[key] = this.extendTypeLiteral(val);
        }
        return ret;
      }
    case 'string':
      Type = this.getTypeInScope(node);
      type = null != Type ? Type.type : void 0;
      switch (typeof type) {
      case 'object':
        return this.extendTypeLiteral(type);
      case 'string':
        return type;
      }
    }
  };
  Scope.prototype.checkAcceptableObject = function (left, right) {
    var l, r;
    l = this.extendTypeLiteral(left);
    r = this.extendTypeLiteral(right);
    return checkAcceptableObject(l, r, this);
  };
  return Scope;
}();
ClassScope = function (super$) {
  extends$(ClassScope, super$);
  function ClassScope() {
    super$.apply(this, arguments);
  }
  void 0;
  return ClassScope;
}(Scope);
FunctionScope = function (super$) {
  extends$(FunctionScope, super$);
  function FunctionScope() {
    super$.apply(this, arguments);
  }
  void 0;
  return FunctionScope;
}(Scope);
module.exports = {
  checkAcceptableObject: checkAcceptableObject,
  initializeGlobalTypes: initializeGlobalTypes,
  VarSymbol: VarSymbol,
  TypeSymbol: TypeSymbol,
  Scope: Scope,
  ClassScope: ClassScope,
  FunctionScope: FunctionScope,
  ArrayType: ArrayType,
  ObjectType: ObjectType,
  Type: Type,
  Possibilites: Possibilites
};
function isOwn$(o, p) {
  return {}.hasOwnProperty.call(o, p);
}
function extends$(child, parent) {
  for (var key in parent)
    if (isOwn$(parent, key))
      child[key] = parent[key];
  function ctor() {
    this.constructor = child;
  }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor;
  child.__super__ = parent.prototype;
  return child;
}
function in$(member, list) {
  for (var i = 0, length = list.length; i < length; ++i)
    if (i in list && list[i] === member)
      return true;
  return false;
}
